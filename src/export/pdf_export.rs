// pdf_export.rs
// Export calculation results as PDF

use super::ExportRecord;
use printpdf::*;
use std::fs::File;
use std::io::BufWriter;

const PAGE_WIDTH_MM: f32 = 210.0;
const PAGE_HEIGHT_MM: f32 = 297.0;
const MARGIN_MM: f32 = 25.0;
const LINE_HEIGHT_MM: f32 = 6.0;

/// Export a single calculation result to PDF file
pub fn export_to_pdf_file(record: &ExportRecord, path: &str) -> Result<(), String> {
    let (doc, page1, layer1) = PdfDocument::new(
        format!("KlinScore - {}", record.score_name),
        Mm(PAGE_WIDTH_MM),
        Mm(PAGE_HEIGHT_MM),
        "Content",
    );

    let font = doc
        .add_builtin_font(BuiltinFont::Helvetica)
        .map_err(|e| e.to_string())?;
    let font_bold = doc
        .add_builtin_font(BuiltinFont::HelveticaBold)
        .map_err(|e| e.to_string())?;

    let layer = doc.get_page(page1).get_layer(layer1);
    let mut y = PAGE_HEIGHT_MM - MARGIN_MM;

    // Title
    write_text(&layer, &font_bold, 18.0, MARGIN_MM, y, "KlinScore");
    y -= LINE_HEIGHT_MM * 1.5;

    // Score name
    write_text(&layer, &font_bold, 14.0, MARGIN_MM, y, &record.score_name);
    y -= LINE_HEIGHT_MM * 1.5;

    // Separator line
    draw_line(&layer, MARGIN_MM, y, PAGE_WIDTH_MM - MARGIN_MM, y);
    y -= LINE_HEIGHT_MM;

    // Total Score
    write_text(
        &layer,
        &font_bold,
        12.0,
        MARGIN_MM,
        y,
        &format!("Total Score: {}", record.total_score),
    );
    y -= LINE_HEIGHT_MM * 1.2;

    // Risk
    write_text(
        &layer,
        &font_bold,
        11.0,
        MARGIN_MM,
        y,
        &format!("Risk: {}", record.risk),
    );
    y -= LINE_HEIGHT_MM * 1.5;

    // Recommendation
    write_text(&layer, &font_bold, 10.0, MARGIN_MM, y, "Recommendation:");
    y -= LINE_HEIGHT_MM;

    // Word-wrap the recommendation text
    y = write_wrapped_text(
        &layer,
        &font,
        9.0,
        MARGIN_MM + 2.0,
        y,
        &record.recommendation,
        PAGE_WIDTH_MM - 2.0 * MARGIN_MM - 2.0,
    );
    y -= LINE_HEIGHT_MM * 0.5;

    // Details if present
    if !record.details.is_empty() {
        write_text(&layer, &font_bold, 10.0, MARGIN_MM, y, "Details:");
        y -= LINE_HEIGHT_MM;
        y = write_wrapped_text(
            &layer,
            &font,
            9.0,
            MARGIN_MM + 2.0,
            y,
            &record.details,
            PAGE_WIDTH_MM - 2.0 * MARGIN_MM - 2.0,
        );
        y -= LINE_HEIGHT_MM * 0.5;
    }

    // Points breakdown
    if !record.field_breakdown.is_empty() {
        y -= LINE_HEIGHT_MM * 0.5;
        draw_line(&layer, MARGIN_MM, y, PAGE_WIDTH_MM - MARGIN_MM, y);
        y -= LINE_HEIGHT_MM;

        write_text(&layer, &font_bold, 10.0, MARGIN_MM, y, "Points Breakdown:");
        y -= LINE_HEIGHT_MM * 1.2;

        for field in &record.field_breakdown {
            let line = format!("  {} pts  {}", field.points, field.label);
            write_text(&layer, &font, 9.0, MARGIN_MM, y, &line);
            y -= LINE_HEIGHT_MM;

            // Start new page if running out of space
            if y < MARGIN_MM + LINE_HEIGHT_MM * 3.0 {
                break;
            }
        }
    }

    // Footer
    y = MARGIN_MM;
    draw_line(
        &layer,
        MARGIN_MM,
        y + LINE_HEIGHT_MM,
        PAGE_WIDTH_MM - MARGIN_MM,
        y + LINE_HEIGHT_MM,
    );
    write_text(
        &layer,
        &font,
        7.0,
        MARGIN_MM,
        y,
        &format!("Generated by KlinScore | {}", record.timestamp),
    );

    // Save to file
    let file = File::create(path).map_err(|e| e.to_string())?;
    let mut buf = BufWriter::new(file);
    doc.save(&mut buf).map_err(|e| e.to_string())?;

    Ok(())
}

fn write_text(
    layer: &PdfLayerReference,
    font: &IndirectFontRef,
    size: f32,
    x: f32,
    y: f32,
    text: &str,
) {
    layer.use_text(text, size, Mm(x), Mm(y), font);
}

/// Write text with word wrapping, return the new y position
fn write_wrapped_text(
    layer: &PdfLayerReference,
    font: &IndirectFontRef,
    size: f32,
    x: f32,
    mut y: f32,
    text: &str,
    max_width_mm: f32,
) -> f32 {
    // Approximate: 1 char ~ 0.5 * font_size / 2.83 mm (rough)
    let chars_per_line = (max_width_mm / (size * 0.18)) as usize;
    if chars_per_line == 0 {
        return y;
    }

    let words: Vec<&str> = text.split_whitespace().collect();
    let mut line = String::new();

    for word in words {
        if line.len() + word.len() + 1 > chars_per_line && !line.is_empty() {
            write_text(layer, font, size, x, y, &line);
            y -= LINE_HEIGHT_MM;
            line.clear();
        }
        if !line.is_empty() {
            line.push(' ');
        }
        line.push_str(word);
    }

    if !line.is_empty() {
        write_text(layer, font, size, x, y, &line);
        y -= LINE_HEIGHT_MM;
    }

    y
}

fn draw_line(layer: &PdfLayerReference, x1: f32, y1: f32, x2: f32, y2: f32) {
    let points = vec![
        (Point::new(Mm(x1), Mm(y1)), false),
        (Point::new(Mm(x2), Mm(y2)), false),
    ];
    let line = Line {
        points,
        is_closed: false,
    };
    layer.set_outline_color(Color::Rgb(Rgb::new(0.5, 0.5, 0.5, None)));
    layer.set_outline_thickness(0.5);
    layer.add_line(line);
}
